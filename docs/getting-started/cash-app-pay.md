---
layout: default
title: Cash App Pay
parent: Getting Started
nav_order: 4
---

# Cash App Pay
{: .d-inline-block .no_toc }
NEW (v4.3.0)
{: .label .label-green }


<details markdown="block">
  <summary>
    Table of contents
  </summary>
  {: .text-delta }
- TOC
{:toc}
</details>


{: .alert }
> Cash App Pay is currently available in the following region(s): US

Cash App Pay support can be added using the your Afterpay merchant account. This requires a token to be generated by a server to server call to the Afterpay API create checkout endpoint with a paramater of `isCashAppPay` set to `true`. This method requires importing and implementing the Cash App PayKit SDK.

{: .info }
> When creating a checkout token, both `redirectConfirmUrl` and `redirectCancelUrl` must be set. Failing to do so will cause undefined behavior. The SDK’s example merchant server sets the parameters [here][example-server-props]{:target='_blank'}. See more by checking the [api reference][api-reference-props]{:target='_blank'}.

## Step 1: Import the Cash App PayKit Dependency

You can get the the latest version of the SDK from Maven. This is the import definition using Gradle:

```gradle
implementation "app.cash.paykit:core:1.0.3"
```

For definitions of other build systems, see [Cash PayKit on Maven Central][cash-on-maven]{:target="_blank"}.

{: .info }
> Version `v1.0.3` of the SDK size is `12.3 kB`.

## Step 2: Create a Cash App PayKit SDK Instance

To create a new instance of the Cash App PayKit SDK, you must pass the `clientId`. This is a required field. This can be retrieved through the Afterpay object: `Afterpay.environment.payKitId`.

{: .note }
> Ensure that the Afterpay SDK is configured per the [instructions][configure-afterpay] before attempting to access `Afterpay.environment.payKitId`


You should use CashAppPayKitFactory to create an instance of the Cash App PayKit SDK. When doing so, you'll need to specify the environment you will use, Sandbox or Production. The function `createSandbox()` will create an SDK instance in the Sandbox environment.

{: .info }
> You should use the Sandbox environment during the development phase and production for your actual production releases.

Creating a sandbox Cash App PayKit SDK instance:

``` kotlin
val payKit : CashAppPayKit = CashAppPayKitFactory.createSandbox(Afterpay.environment.payKitId)
```

Creating a production Cash App PayKit SDK instance:
``` kotlin
val payKit : CashAppPayKit = CashAppPayKitFactory.create(Afterpay.environment.payKitId)
```

{: .info }
**Optional:** We recommend using the [Cash App Sandbox App][sandbox-app]{:target="_blank"} to compare the Sandbox environment of the SDK during your development phase.

## Step 3: Register for State Updates

To receive updates from Pay Kit, you’ll need to implement the `CashAppPayKitListener` interface. The interface exposes a single function, which gets called whenever there’s an internal state change emitted by the SDK:

``` kotlin
interface CashAppPayKitListener {
   fun payKitStateDidChange(newState: PayKitState)
}
```

You register with the SDK instance you’ve created above:

``` kotlin
payKit.registerForStateUpdates(this)
```

You should also use the unregister function when you're done with the SDK:

``` kotlin
payKit.unregisterFromStateUpdates()
```

### States

`PayKitState` is a sealed class parameter. We suggest that you use a Kotlin `when` statement on it. Some of these possible states are for information only, but most drive the logic of your integration. The most critical states to handle are in the table below:

| State  | Description |
|:-------|:------------|
| `ReadyToAuthorize` | Show a Cash App Pay button in your UI and call `authorizeCustomerRequest()` when it is tapped |
| `Approved` | Grants are ready for your backend to use to create a payment |
| `Declined` | Customer has declined the Cash App Pay authorization and must start the flow over or choose a new payment method |
| `PayKitExceptionState` | The general wrapper state for exceptions. These can range from integration errors to network errors. The exception states are emitted only for unrecoverable error states. |

## Step 4: Implement Deep Linking Handling

The authorization flow will bring Cash App to the foreground on the Customer’s device. After the Customer either authorizes or declines, your app must be returned to the foreground, which means we need a way to call your app from Cash App.  This is accomplished by [declaring an incoming intent][intent-filter]{:target="_blank"} filter on your app's Android Manifest and passing a corresponding redirect URI that uses the SDK when creating a customer request (as can be seen on the next step).

Here’s an example how this integration looks like for your `AndroidManifest`:

``` xml
<intent-filter>
  <action android:name="android.intent.action.VIEW" />

  <category android:name="android.intent.category.DEFAULT" />
  <category android:name="android.intent.category.BROWSABLE" />

  <!-- Register the Cash PayKit redirect URI or URL. Change this accordingly in your app. -->
  <data
      android:scheme="cashpaykit"
      android:host="checkout" />
</intent-filter>
```

## Step 5: Create a Customer Request

You can create a customer request as soon as you know the amount you’d like to charge or if you'd like to create an on-file payment request. We suggest that you create this request as soon as your checkout view controller loads, so that your Customer can authorize the request without delay.

### Step 5A: Setup the Afterpay Cash App Pay Handler

Setup a handler to manage the data when received from signing the order token. Alternatively this can be passed in as the `handler` parameter in step 5B.

``` kotlin
class ExampleActivity: Activity {
  Afterpay.setCashAppHandler(object : AfterpayCashAppHandler {
    override fun didReceiveCashAppData(cashAppData: CashAppSignOrderResult) {
      when (cashAppData) {
        is CashAppSignOrderResult.Success -> TODO("Create the PayKit customemr request")
        is CashAppSignOrderResult.Failure -> TODO("Display an error and restart payment flow")
      }
    }
  })
}
```

### Step 5B: Sign the Order Token

After retrieving the token from your server to server call, the order needs to be signed, so as to retrieve the JWT and associated data. This can be done either by the suspending function:

``` kotlin
Afterpay.signCashAppOrder(token)
```

or with the async version of it:

``` kotlin
Afterpay.signCashAppOrderAsync(token)
```

### Step 5C: Create a PayKit Customer Request

To charge $5.00 as a one-time payment, your createrequest call might look like this (in the below example, `cashAppData` is the response object that is returned in the `didReceiveCashAppData` handler method):

``` kotlin
val request = PayKitPaymentAction.OneTimeAction(
  redirectUri = cashAppData.redirectUri,
  currency = PayKitCurrency.USD,
  amount = (cashAppData.amount * 100).toInt(),
  scopeId = cashAppData.merchantId,
)

payKit.createCustomerRequest(request)
```

### Step 5D: Validate the Cash App Pay Order

{: .alert }
> This step must not be skipped

Finally the Cash App order must be validated. This looks something like the below:

``` kotlin
Afterpay.validateCashAppOrder(
    jwt,
    grant.id,
    customerResponseData.customerProfile!!.id,
) { validationResult ->
    when (validationResult) {
      is CashAppValidationResponse.Success -> TODO("Capture payment with token and grant id")
      is CashAppValidationResponse.Failure -> TODO("Handle an invalid Cash App order")
    }
}
```

## Step 6: Authorize the Customer Request

Once the Cash App PayKit SDK is in the `ReadyToAuthorize` state, you can display the Cash App Pay button. When the Customer taps the button, you can authorize the customer request. Documentation for a Cash App Pay button component can be found [here][cash-button-docs]{:target='_blank'}

``` kotlin
payKit.authorizeCustomerRequest()
```
{: .info }
> Currently, the Button provided by the SDK is unmanaged. This means that it's a stylized button which isn't aware of SDK events out-of-the-box. It is the developer's responsibility to call the above method when the button is clicked and also manage any disabled and loading states.

Your app will redirect to Cash App for authorization. When the authorization is completed, your redirect URI will be called to open your app. The SDK will fetch your authorized request and return it to your callback listener as one of 2 states: `Approved` or `Declined`.

## Step 7: Pass Grants to the Backend and Capture Payment

The `Approved` state will contain a Grants list object associated with it and it can be used with Afterpay's capture payment API. Pass the grant id along with the token to capture using a server to server request.

[cash-on-maven]: https://central.sonatype.com/artifact/app.cash.paykit/core/1.0.3/overview
[configure-afterpay]: ../configuring-the-sdk
[sandbox-app]: https://cashapp-pay.stoplight.io/docs/api/technical-documentation/sandbox/sandbox-app
[intent-filter]: https://developer.android.com/training/app-links/deep-linking#adding-filters
[example-server-props]: https://github.com/afterpay/sdk-example-server/blob/5781eadb25d7f5c5d872e754fdbb7214a8068008/src/routes/checkout.ts#L26-L27
[api-reference-props]: https://developers.afterpay.com/afterpay-online/reference/javascript-afterpayjs#redirect-method
[cash-button-docs]: https://cashapp-pay.stoplight.io/docs/api/technical-documentation/sdks/pay-kit/android-getting-started#cashpaykitbutton
